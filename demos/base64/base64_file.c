/*
 * Copyright (c) 2022 Leon Weinmann
 *
 * Licensed under the MIT License. You may not use
 * this file except in compliance with the License. You can obtain a copy
 * in the file LICENSE in the source distribution.
 */

#include <cryptowrap/base64.h>
#include <cryptowrap/error.h>

#include <openssl/bio.h>
#include <openssl/evp.h>

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>

uint8_t rawData[195] = {
    0x50, 0x65, 0x61, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6C,
    0x69, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x69, 0x6F,
    0x6E, 0x2E, 0x20, 0x54, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x50,
    0x61, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x2C, 0x49, 0x20, 0x67, 0x61, 0x69,
    0x6E, 0x20, 0x53, 0x74, 0x72, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x2E, 0x20,
    0x54, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x53, 0x74, 0x72, 0x65,
    0x6E, 0x67, 0x74, 0x68, 0x2C, 0x49, 0x20, 0x67, 0x61, 0x69, 0x6E, 0x20,
    0x50, 0x6F, 0x77, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x72, 0x6F, 0x75,
    0x67, 0x68, 0x20, 0x50, 0x6F, 0x77, 0x65, 0x72, 0x2C, 0x49, 0x20, 0x67,
    0x61, 0x69, 0x6E, 0x20, 0x56, 0x69, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x2E,
    0x20, 0x54, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x56, 0x69, 0x63,
    0x74, 0x6F, 0x72, 0x79, 0x20, 0x6D, 0x79, 0x20, 0x63, 0x68, 0x61, 0x69,
    0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x42, 0x72, 0x6F, 0x6B, 0x65,
    0x6E, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x46, 0x6F, 0x72, 0x63, 0x65,
    0x20, 0x73, 0x68, 0x61, 0x6C, 0x6C, 0x20, 0x66, 0x72, 0x65, 0x65, 0x20,
    0x6D, 0x65, 0x2E};

#define FILE_PATH "base64_file_interface.txt"
#define FILE_PATH_OUTPUT "base64_file_interface_out.txt"

void fill_file()
{
    FILE *fp = NULL;

    if ((fp = fopen(FILE_PATH, "wb")) == NULL)
        goto END;

    fwrite(rawData, sizeof(uint8_t), sizeof(rawData), fp);

END:
    if (fp != NULL)
        fclose(fp);
}

void helper_print_file_contents(const char *file_path)
{
    FILE *fp = NULL;
    uint8_t buf[20] = {0};
    size_t bytes_read = 0;

    if ((fp = fopen(file_path, "rb")) == NULL)
        return;

    while ((bytes_read = fread(buf, sizeof(uint8_t), sizeof(buf), fp)) > 0)
    {
        fwrite(buf, sizeof(uint8_t), bytes_read, stdout);
    }

    fclose(fp);
}

/*
    This function reads the file contents and encoded them into a buffer
*/
void Encode_file()
{
    uint8_t *encoded = NULL;
    uint64_t encoded_len = 0;

    // Encode the data -> output is allocated within the function
    if (cw_base64_file_encode_out(FILE_PATH, &encoded, &encoded_len, 0) != 1)
    {
        cw_error_get_last_error_fp_ex(stdout);
        goto END;
    }

    // Print out the encoded buffer
    printf("Base64 encoded buffer:\n");
    BIO_dump_fp(stdout, encoded, encoded_len);

END:
    if (encoded != NULL)
        free(encoded);
}

/*
    This function encodes file contents into an other file
*/
void Encode_file_to_file()
{
    // Encode the data -> output is written into a different file
    if (cw_base64_file_encode(FILE_PATH, FILE_PATH_OUTPUT) != 1)
    {
        cw_error_get_last_error_fp_ex(stdout);
        return;
    }

    // Print file contents
    printf("\nEncoded contents in output file:\n");
    helper_print_file_contents(FILE_PATH_OUTPUT);
}

int main()
{
    // Create a file an fill it with contents
    fill_file();

    Encode_file();

    Encode_file_to_file();
}