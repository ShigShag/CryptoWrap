/*
 * Copyright (c) 2022 Leon Weinmann
 *
 * Licensed under the MIT License. You may not use
 * this file except in compliance with the License. You can obtain a copy
 * in the file LICENSE in the source distribution.
 */

#include <cryptowrap/base64.h>
#include <cryptowrap/error.h>

#include <openssl/bio.h>

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>

uint8_t rawData[195] = {
    0x50, 0x65, 0x61, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6C,
    0x69, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x69, 0x6F,
    0x6E, 0x2E, 0x20, 0x54, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x50,
    0x61, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x2C, 0x49, 0x20, 0x67, 0x61, 0x69,
    0x6E, 0x20, 0x53, 0x74, 0x72, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x2E, 0x20,
    0x54, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x53, 0x74, 0x72, 0x65,
    0x6E, 0x67, 0x74, 0x68, 0x2C, 0x49, 0x20, 0x67, 0x61, 0x69, 0x6E, 0x20,
    0x50, 0x6F, 0x77, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x72, 0x6F, 0x75,
    0x67, 0x68, 0x20, 0x50, 0x6F, 0x77, 0x65, 0x72, 0x2C, 0x49, 0x20, 0x67,
    0x61, 0x69, 0x6E, 0x20, 0x56, 0x69, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x2E,
    0x20, 0x54, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x56, 0x69, 0x63,
    0x74, 0x6F, 0x72, 0x79, 0x20, 0x6D, 0x79, 0x20, 0x63, 0x68, 0x61, 0x69,
    0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x42, 0x72, 0x6F, 0x6B, 0x65,
    0x6E, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x46, 0x6F, 0x72, 0x63, 0x65,
    0x20, 0x73, 0x68, 0x61, 0x6C, 0x6C, 0x20, 0x66, 0x72, 0x65, 0x65, 0x20,
    0x6D, 0x65, 0x2E};

/*
    Encrypt the data with a stream
    Same principle can be applied when decoding
*/
void base64_stream()
{
    uint8_t *encoded = NULL;

    int buffer_size = 1;
    uint64_t bytes_processed = 0;

    uint64_t total_bytes_encoded = 0;
    int temp_bytes_encoded = 0;

    BASE64_STREAM_HANDLE handle = NULL;

    // Initialize stream handle
    if (cw_base64_stream_init(&handle, BASE64_STREAM_ENCODE) != 1)
    {
        cw_error_get_last_error_fp_ex(stdout);
        goto END;
    }

    // Allocate the output buffer -> size should be about 1.5 of the plaintext size
    if (((encoded = calloc(sizeof(rawData) * 1.5, sizeof(uint8_t))) == NULL))
    {
        fprintf(stderr, "Calloc failed\n");
        goto END;
    }

    // This no real life application -> Buffer size is set to one to
    // show how the stream functions should be called
    while (bytes_processed < sizeof(rawData))
    {
        if (cw_base64_stream_update(handle, encoded + total_bytes_encoded, &temp_bytes_encoded,
                                    rawData + bytes_processed, buffer_size) != 1)
        {
            cw_error_get_last_error_fp_ex(stdout);
            goto END;
        }

        bytes_processed += buffer_size;
        total_bytes_encoded += temp_bytes_encoded;
    }

    // Finalize the operation
    if (cw_base64_stream_final(handle, encoded + total_bytes_encoded, &temp_bytes_encoded) != 1)
    {
        cw_error_get_last_error_fp_ex(stdout);
        goto END;
    }

    total_bytes_encoded += temp_bytes_encoded;

    // Adjust size of the buffer
    if ((sizeof(rawData) * 1.5) != total_bytes_encoded)
    {
        uint8_t *temp = realloc(encoded, total_bytes_encoded);
        if (temp == NULL)
        {
            fprintf(stderr, "Realloc failed\n");
            goto END;
        }
        encoded = temp;
    }

    // Print the results
    BIO_dump_fp(stdout, encoded, total_bytes_encoded);

END:
    // Free the handle
    if (handle != NULL)
        cw_base64_stream_delete(handle);

    if (encoded != NULL)
        free(encoded);
}

int main()
{
    base64_stream();

    return EXIT_SUCCESS;
}